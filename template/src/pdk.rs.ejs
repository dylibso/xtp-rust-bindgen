// THIS FILE WAS GENERATED BY `xtp-rust-bindgen`. DO NOT EDIT.

#![allow(non_snake_case)]
use extism_pdk::*;

pub(crate) mod internal {
    pub(crate) fn return_error(e: extism_pdk::Error) -> i32 {
        let err = format!("{:?}", e);
        let mem = extism_pdk::Memory::from_bytes(&err).unwrap();
        unsafe {
            extism_pdk::extism::error_set(mem.offset());
        }
        -1
    }
}

#[allow(unused)]
macro_rules! try_input {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(x) => x,
            Err(e) => return internal::return_error(e),
        }
    }}
}

#[allow(unused)]
macro_rules! try_input_json {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(extism_pdk::Json(x)) => x,
            Err(e) => return internal::return_error(e),
        }
    }}
}

use base64_serde::base64_serde_type;

base64_serde_type!(Base64Standard, base64::engine::general_purpose::STANDARD);


mod exports {
    use super::*;
<% schema.exports.forEach(ex => { -%>

#[no_mangle]
pub extern "C" fn <%- ex.name %>() -> i32 {
    <% if (ex.output && ex.output.contentType === "application/json") { %>
    let ret = crate::<%- camelToSnakeCase(ex.name) %>(<% if (ex.input) { %>  <% if (ex.input.contentType === "application/json") { %> try_input_json!() <% } else { %> try_input!() <% } %> <% } %>).and_then(|x| extism_pdk::output(extism_pdk::Json(x)));
    <% } else { %>
    let ret = crate::<%- camelToSnakeCase(ex.name) %>(<% if (ex.input) { %> <% if (ex.input.contentType === "application/json") { %> try_input_json!() <% } else { %> try_input!() <% } %> <% } %>).and_then(extism_pdk::output);
    <% } %>
    match ret {
        Ok(()) => {
            0
        }
        Err(e) => {
            internal::return_error(e)
        }
    }
}
<% }) %>
}

pub mod types {
    #[derive(serde::Serialize, serde::Deserialize, extism_pdk::FromBytes, extism_pdk::ToBytes)]
    #[encoding(Json)]
    #[serde(transparent)]
    pub struct Base64(pub #[serde(with = "Base64Standard")] Vec<u8>);

    use super::*;
<% Object.values(schema.schemas).forEach(schema => { %>
    <% if (schema.enum) { %>
#[derive(serde::Serialize, serde::Deserialize, extism_pdk::FromBytes, extism_pdk::ToBytes)]
#[encoding(Json)]
pub enum <%- capitalize(schema.name) %> {
    <% schema.enum.forEach(variant => { -%>
    #[serde(rename = "<%- variant %>")]
    <%- capitalize(variant) %>,
		<% }) %>
}
    <% } else { %>
#[derive(serde::Serialize, serde::Deserialize, extism_pdk::FromBytes, extism_pdk::ToBytes)]
#[encoding(Json)]
pub struct <%- capitalize(schema.name) %> {
    <% schema.properties.forEach(p => { -%>
		<% if (p.description) { -%>
		/// <%- formatCommentBlock(p.description, "/// ") %>
		<% } -%>
    #[serde(rename = "<%- p.name %>")]
    <% if (!p.required && p.nullable) { %> #[serde(skip_serializing_if = "Option::is_none")] <% } %>
    <% if (p.type === "buffer") { %>
		<%- makePublic(camelToSnakeCase(p.name)) %>: <%- p.nullable || !p.required ? `Option<Base64>` : Base64 %>,
    <% } else { %>
		<%- makePublic(camelToSnakeCase(p.name)) %>: <%- p.nullable || !p.required ? `Option<${toRustType(p)}>` : toRustType(p) %>,
    <% } %>
		<% }) %>

    <% if (schema.additionalProperties) { %>
    #[serde(flatten)]
    additional_properties: std::collections::HashMap<String, <%- schema.additionalProperties.type ? toRustType(schema.additionalProperties.type) : "serde_json::Value" %>>,
    <% } %>
}
    <% } %>
<% }); %>
}

mod raw_imports {
    use super::*;
    #[host_fn]
    extern "ExtismHost" {
<% schema.imports.forEach(imp => { %>
        pub(crate) fn <%- imp.name %>(<% if (imp.input) { -%>input: <% if (imp.input.contentType === "application/json") { %><%- jsonWrappedRustType(imp.input) %><%} else {%> <%- toRustType(imp.input) %> <%}%><%} -%>) <% if (imp.output) { -%> -> <% if (imp.output.contentType === "application/json") {%> <%- jsonWrappedRustType(imp.output) %> <%} else {%> <%-toRustType(imp.output) %> <%}%><% } -%>;
<% }) %>
    }
}

<% schema.imports.forEach(imp => { %>
<% if (hasComment(imp)) -%>
/// <%- imp.name %> <%- formatCommentBlock(imp.description, "/// ") %>
<% if (hasComment(imp.input)) { -%>
/// It takes input of <%- toRustType(imp.input) %> (<%- formatCommentLine(imp.input.description) %>)
<% } -%>
<% if (hasComment(imp.output)) { -%>
/// And it returns an output <%- toRustType(imp.output) %> (<%- formatCommentLine(imp.output.description) %>)
<% } -%>
#[allow(unused)]
pub(crate) fn <%- camelToSnakeCase(imp.name) %>(<% if (imp.input) { -%>input: <%- toRustType(imp.input) %><%} -%>) -> std::result::Result<<% if (imp.output) { -%><%- toRustType(imp.output) %><% } else { -%> () <% } %> , extism_pdk::Error>  {
    let res = unsafe {
        raw_imports::<%- imp.name %>(
            <% if (imp.input) { %> <% if (imp.input.contentType === "application/json") { %> extism_pdk::Json(input) <%} else {%> input <%}%> <% } %>
        )?
    };

    <% if (imp.output && imp.output.contentType === "application/json") { %> 
    let extism_pdk::Json(res) = res;
    <% } %>

    Ok(res)
}
<% }) %>
